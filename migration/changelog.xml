<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-2.0.xsd">


	<!-- TODO 
		work out if we really need the trim. 
		
		also there are plenty of places that we are not using it. 
		
		eg. the classification_scheme tables.
	-->


	<!--
		should not have stray uid's around the place ...
	-->

	<!--
		IMPORTANT
			- person_organisational_affiliation, could/should have the affiliation put in
			the responsible party. but leave for the moment.
			- and lave as null if no affiliation. if only person or organisation is present.
			- but leave for now.
	-->
	<!--
		IMPORTANT
		There are many nerc references in the internal_associations_table

		psql -h 127.0.0.1 -U contr_vocab_db -d vocab -c 'select name,uid from vocabulary_term where uid ~ $$nerc$$ '

		Ok - because uses external_associations_table  Why ?
	-->
	<!--
		think we want to change responsible_party to party
	-->




	<!-- rename tables -->
	<changeSet author="julian" id="000001">
		<renameTable newTableName="affiliation_type" oldTableName="affiliation_type_table" />											<!-- done -->
		<renameTable newTableName="amendment" oldTableName="amendment_table" />															<!-- done -->
		<renameTable newTableName="association_type" oldTableName="association_type_table" />											<!-- done - one string but ok -->
		<renameTable newTableName="classification_scheme_association" oldTableName="classification_scheme_association_table" />
		<renameTable newTableName="classification_scheme_category" oldTableName="classification_scheme_category_table" />
		<renameTable newTableName="classification_scheme" oldTableName="classification_scheme_table" />
		<renameTable newTableName="external_associated_terms" oldTableName="external_associated_terms_table" />							<!-- good -->
		<renameTable newTableName="internal_associated_terms" oldTableName="internal_associated_terms_table" />
		<renameTable newTableName="object_term" oldTableName="object_term_table" />
		<renameTable newTableName="organisation" oldTableName="organisation_name_table" />												<!-- good -->
		<renameTable newTableName="organisation_synonym" oldTableName="organisation_synonym_table" />									<!-- good -->
		<renameTable newTableName="person_organisational_affiliation" oldTableName="person_organisational_affiliation_table" />			<!-- ok but has 3 field composite key?? -->
		<renameTable newTableName="person" oldTableName="person_table" />																<!-- good -->
		<renameTable newTableName="reference_source" oldTableName="reference_source_table" />											<!-- good -->
		<renameTable newTableName="register_manager" oldTableName="register_manager_table" />											<!-- removed -->
		<renameTable newTableName="register_owner" oldTableName="register_owner_table" />												<!-- removed -->
		<renameTable newTableName="subject_term" oldTableName="subject_term_table" />
		<renameTable newTableName="term_category_classification" oldTableName="term_category_classification_table" />
		<renameTable newTableName="term_proposer" oldTableName="term_proposer_table" />													<!-- removed -->
		<renameTable newTableName="vocabulary_register" oldTableName="vocabulary_register_table" />
		<renameTable newTableName="vocabulary_term" oldTableName="vocabulary_term_table" />												<!-- ok -->
		<renameTable newTableName="vocabulary_type" oldTableName="vocabulary_type_table" />												<!-- good -->
	</changeSet>

	<changeSet author="julian" id="000001-5">
       <sql>
			create function exec(text) returns text
			language plpgsql volatile
			as $$ begin execute $1; return $1; end; $$;
			grant all on function exec(text) to public
       </sql>
	</changeSet>



	<!-- organisation name -->
	<changeSet author="julian" id="000002">
		<renameColumn newColumnName="id" oldColumnName="organisation_name_id" tableName="organisation"/>
		<renameColumn newColumnName="name" oldColumnName="organisation_name" tableName="organisation"/>
		<renameColumn newColumnName="description" oldColumnName="organisation_name_description" tableName="organisation"/>
		<renameColumn newColumnName="acronym" oldColumnName="organisation_acronym" tableName="organisation"/>
		<renameColumn newColumnName="address" oldColumnName="organisation_address" tableName="organisation"/>
		<renameColumn newColumnName="status" oldColumnName="organisation_name_status" tableName="organisation"/>
		<renameColumn newColumnName="notes" oldColumnName="organisation_notes" tableName="organisation"/>
		<!-- normalize - use organisation synonym table instead -->
		<dropColumn columnName="organisation_synonym" tableName="organisation"/>
		<!-- sequence on primary key -->
		<sql>
			select exec('create sequence organisation_id_seq start '||(select max(id) +1 from organisation));
			alter table organisation alter column id set default nextval('organisation_id_seq')
		</sql>
	</changeSet>


	<!-- person -->
	<changeSet author="julian" id="000003">
		<renameColumn newColumnName="id" oldColumnName="person_id" tableName="person"/>
		<renameColumn newColumnName="name" oldColumnName="person_name" tableName="person"/>
		<renameColumn newColumnName="salutation" oldColumnName="person_salutation" tableName="person"/>
		<renameColumn newColumnName="email" oldColumnName="contact_email" tableName="person"/>
		<!-- sequence on primary key -->
		<sql>
			select exec('create sequence person_id_seq start '||(select max(id) +1 from person));
			alter table person alter column id set default nextval('person_id_seq')
		</sql>
	</changeSet>


	<!-- new table responsible party to replace register_owner, register_manager, term_proposer etc
		should probably also incorporate affiliation_type since it's a one-to-one mapping
	-->
	<changeSet author="julian" id="000004">
		<createTable tableName="responsible_party" >
			<column name="id" type="serial">
				 <constraints primaryKey="true"/>
			</column>
			<column name="person_id" type="integer"/>
			<column name="organisation_id" type="integer"/>
		</createTable>
		<addUniqueConstraint columnNames="person_id,organisation_id" tableName="responsible_party" />
		<sql>
			-- this is very flexible, for adding other entries - and affiliation_type if we need
			insert into responsible_party (person_id, organisation_id)
			select p.id, o.id
			from person p
			cross join organisation o
			where ( o.acronym ~ 'eMII' and p.name ~ 'Seb' )
			or ( o.acronym ~ 'IMOS' and p.name ~ 'Seb' )
		</sql>
	</changeSet>


	<!-- vocabulary_register -->
	<changeSet author="julian" id="000005">
		<!-- integer primary key -->
		<sql>
			alter table vocabulary_register drop constraint vocabulary_register_table_pkey cascade
		</sql>
		<addColumn tableName="vocabulary_register">
			<column name="id" type="serial"/>
		</addColumn>
		<addPrimaryKey columnNames="id" tableName="vocabulary_register" />

		<!-- rename -->
		<renameColumn newColumnName="uid" oldColumnName="register_uid" tableName="vocabulary_register"/>
		<renameColumn newColumnName="name" oldColumnName="register_name" tableName="vocabulary_register"/>
		<renameColumn newColumnName="content_summary" oldColumnName="register_content_summary" tableName="vocabulary_register"/>
		<renameColumn newColumnName="language_name" oldColumnName="register_language_name" tableName="vocabulary_register"/>
		<renameColumn newColumnName="language_code" oldColumnName="register_language_code" tableName="vocabulary_register"/>
		<renameColumn newColumnName="language_country" oldColumnName="register_language_country" tableName="vocabulary_register"/>
		<renameColumn newColumnName="language_encoding" oldColumnName="register_language_encoding" tableName="vocabulary_register"/>
		<renameColumn newColumnName="version" oldColumnName="register_version" tableName="vocabulary_register"/>
		<renameColumn newColumnName="date" oldColumnName="register_date" tableName="vocabulary_register"/>

		<!-- constraints -->
		<addUniqueConstraint columnNames="name" tableName="vocabulary_register" />
		<addNotNullConstraint columnName="name" tableName="vocabulary_register"/>

		<addUniqueConstraint columnNames="uid" tableName="vocabulary_register" />
		<addNotNullConstraint columnName="uid" tableName="vocabulary_register"/>


		<!-- use responsible_party and drop register_manager table -->
		<addColumn tableName="vocabulary_register">
			<column name="manager_responsible_party_id" type="integer"/>
		</addColumn>
		<sql>
			-- eg. 1
			update vocabulary_register vr set manager_responsible_party_id = rp.id
			from responsible_party rp, register_manager rm
			where vr.name = rm.register_name
			and rm.person_id = rp.person_id
			and rm.organisation_name_id = rp.organisation_id
		</sql>
	    <addForeignKeyConstraint
            constraintName="vocabulary_register_manager_responsible_party_fkey"
			baseColumnNames="manager_responsible_party_id"
            baseTableName="vocabulary_register"
            referencedColumnNames="id"
            referencedTableName="responsible_party"
		/>
		<dropTable tableName="register_manager"/>


		<!-- use responsible_party and drop register_owner table -->
		<addColumn tableName="vocabulary_register">
			<column name="owner_responsible_party_id" type="integer"/>
		</addColumn>
		<sql>
			-- eg. 1
			update vocabulary_register vr set owner_responsible_party_id = rp.id
			from responsible_party rp, register_owner ro
			where vr.name = ro.register_name
			and ro.person_id = rp.person_id
			and ro.organisation_name_id = rp.organisation_id
		</sql>
	    <addForeignKeyConstraint
            constraintName="vocabulary_register_owner_responsible_party_fkey"
			baseColumnNames="owner_responsible_party_id"
            baseTableName="vocabulary_register"
            referencedColumnNames="id"
            referencedTableName="responsible_party"
		/>
		<dropTable tableName="register_owner"/>

	</changeSet>



	<!-- vocabulary_term -->
	<changeSet author="julian" id="000006">
		<!-- remove old primary key, add new integer one -->
		<sql>
			alter table vocabulary_term drop constraint vocabular_term_table_pkey cascade;
		</sql>

		<!-- primary but not serial -->
		<renameColumn newColumnName="id" oldColumnName="vocabulary_term_code" tableName="vocabulary_term"/>
		<addPrimaryKey columnNames="id" tableName="vocabulary_term" />
		<sql>
			-- drop sequence vocabulary_term_id_seq;
			select exec('create sequence vocabulary_term_id_seq start '||(select max(id) +1 from vocabulary_term));
			alter table vocabulary_term alter column id set default nextval('vocabulary_term_id_seq')
		</sql>


		<!-- unique constraint on name -->
		<renameColumn newColumnName="name" oldColumnName="vocabulary_term_name" tableName="vocabulary_term"/>
		<addUniqueConstraint columnNames="name" tableName="vocabulary_term" />
		<addNotNullConstraint columnName="name" tableName="vocabulary_term"/>

		<!-- unique constraint on uid -->
		<renameColumn newColumnName="uid" oldColumnName="vocabulary_term_uid" tableName="vocabulary_term"/>
		<addUniqueConstraint columnNames="uid" tableName="vocabulary_term" />
		<addNotNullConstraint columnName="uid" tableName="vocabulary_term"/>

		<!-- clean up column naming -->
		<renameColumn newColumnName="short_name" oldColumnName="vocabulary_term_short_name" tableName="vocabulary_term"/>
		<renameColumn newColumnName="ancillary_information" oldColumnName="vocabulary_term_ancillary_information" tableName="vocabulary_term"/>
		<renameColumn newColumnName="definition" oldColumnName="vocabulary_term_definition" tableName="vocabulary_term"/>

		<!-- normalize -->
		<dropColumn columnName="internal_relationship" tableName="vocabulary_term"/>
		<dropColumn columnName="external_relationship" tableName="vocabulary_term"/>
		<dropColumn columnName="vocabulary_instance_of" tableName="vocabulary_term"/>

		<!-- term_proposer responsible party and drop term_proposer table and existing ref -->
		<dropColumn columnName="term_proposer_id" tableName="vocabulary_term"/>
		<addColumn tableName="vocabulary_term">
			<column name="proposer_responsible_party_id" type="integer"/>
		</addColumn>
		<sql>
			update vocabulary_term set proposer_responsible_party_id = 1
		</sql>
	    <addForeignKeyConstraint
            constraintName="vocabulary_term_proposer_responsible_party_fkey"
			baseColumnNames="proposer_responsible_party_id"
            baseTableName="vocabulary_term"
            referencedColumnNames="id"
            referencedTableName="responsible_party"
		/>
		<dropTable tableName="term_proposer"/>


		<!-- vocabulary_term to use vocabulary_register(id) -->
		<addColumn tableName="vocabulary_term">
			<column name="vocabulary_register_id" type="integer"/>
		</addColumn>
		<sql>
			update vocabulary_term vt set vocabulary_register_id = vr.id
			from vocabulary_register vr
			where vr.name = vt.register_name
		</sql>
	    <addForeignKeyConstraint
            constraintName="vocabulary_term_vocabulary_register_fkey"
			baseColumnNames="vocabulary_register_id"
            baseTableName="vocabulary_term"
            referencedColumnNames="id"
            referencedTableName="vocabulary_register"
		/>
		<dropColumn columnName="register_name" tableName="vocabulary_term"/>


		<!-- change added_by to point at person table -->
		<addColumn tableName="vocabulary_term">
			<column name="added_by_person_id" type="integer"/>
		</addColumn>
		<sql>
			update vocabulary_term vt set added_by_person_id = p.id
			from person p
			where lower( p.name) = lower( regexp_replace(vt.added_by, '(.*) (.*).*', '\2, \1'))
		</sql>
	    <addForeignKeyConstraint
            constraintName="vocabulary_term_added_by_person_fkey"
			baseColumnNames="added_by_person_id"
            baseTableName="vocabulary_term"
            referencedColumnNames="id"
            referencedTableName="person"
		/>
		<dropColumn columnName="added_by" tableName="vocabulary_term"/>
	</changeSet>




	<!-- external_associated_terms -->
	<changeSet author="julian" id="000007">
		<!-- dont need primary keys here -->

		<!-- reference vocabulary_term(id) -->
		<addColumn tableName="external_associated_terms">
			<column name="vocabulary_term_id" type="integer"/>
		</addColumn>
		<sql>
			update external_associated_terms a set vocabulary_term_id = v.id
			from vocabulary_term v
			where v.name = a.vocabulary_term_name
		</sql>
	    <addForeignKeyConstraint
            constraintName="external_associated_terms_vocabulary_term_id_fkey"
			baseColumnNames="vocabulary_term_id"
            baseTableName="external_associated_terms"
            referencedColumnNames="id"
            referencedTableName="vocabulary_term"
		/>
		<dropColumn columnName="vocabulary_term_name" tableName="external_associated_terms"/>

		<renameColumn newColumnName="uid" oldColumnName="external_term_uid" tableName="external_associated_terms"/>

		<!-- enforce tuple uniqueness -->
		<addUniqueConstraint columnNames="vocabulary_term_id,uid,association_type_name" tableName="external_associated_terms" />
		<addNotNullConstraint columnName="uid" tableName="external_associated_terms"/>
		<addNotNullConstraint columnName="association_type_name" tableName="external_associated_terms"/>

		<!-- delete badly loaded data, whereby external terms refer to themselves via the vocabulary_table -->
		<sql>
			delete from external_associated_terms eat
			using vocabulary_term vt
			where eat.vocabulary_term_id = vt.id
			and eat.uid = vt.uid;
		</sql>

		<!-- note the uid is correct - and represents a real external resource
			that is not repeated anywhere else -->

	</changeSet>




	<!-- amendment -->
	<changeSet author="julian" id="000008">

		<!-- id is already primary key, but not serial -->
		<renameColumn newColumnName="id" oldColumnName="amendment_id" tableName="amendment"/>
		<sql>
			select exec('create sequence amendment_id_seq start '||(select max(id) +1 from amendment));
			alter table amendment alter column id set default nextval('amendment_id_seq')
		</sql>

		<addColumn tableName="amendment">
			<column name="vocabulary_term_id" type="integer"/>
		</addColumn>
		<sql>
			update amendment a set vocabulary_term_id = v.id
			from vocabulary_term v
			where v.name = a.vocabulary_term_name
		</sql>
	    <addForeignKeyConstraint
            constraintName="amendment_vocabulary_term_id_fkey"
			baseColumnNames="vocabulary_term_id"
            baseTableName="amendment"
            referencedColumnNames="id"
            referencedTableName="vocabulary_term"/>
		 <addNotNullConstraint columnName="vocabulary_term_id" tableName="amendment"/>

		<!-- normalize -->
		<dropColumn columnName="vocabulary_term_name" tableName="amendment"/>
		<dropColumn columnName="vocabulary_term_code" tableName="amendment"/>


		<renameColumn newColumnName="type" oldColumnName="amendment_type" tableName="amendment"/>
		<renameColumn newColumnName="request_date" oldColumnName="amendment_request_date" tableName="amendment"/>
		<renameColumn newColumnName="approval_date" oldColumnName="amendment_approval_date" tableName="amendment"/>

		<!-- use vocabulary_register primary key id -->
		<addColumn tableName="amendment">
			<column name="vocabulary_register_id" type="integer"/>
		</addColumn>
		<sql>
			update amendment a set vocabulary_register_id = vr.id
			from vocabulary_register vr
			where vr.name = a.register_name
		</sql>
	    <addForeignKeyConstraint
            constraintName="amendment_vocabulary_register_id_fkey"
			baseColumnNames="vocabulary_register_id"
            baseTableName="amendment"
            referencedColumnNames="id"
            referencedTableName="vocabulary_register"
		/>
		<dropColumn columnName="register_name" tableName="amendment"/>


		<!-- amendment to use responsible party, and drop person,organisation fields -->
		<addColumn tableName="amendment">
			<column name="responsible_party_id" type="integer"/>
		</addColumn>
		<sql>
			-- eg. 1
			update amendment a set responsible_party_id = rp.id
			from responsible_party rp
			where a.person_id = rp.person_id
			and a.organisation_name_id = rp.organisation_id
		</sql>
	    <addForeignKeyConstraint
            constraintName="amendment_responsible_party_fkey"
			baseColumnNames="responsible_party_id"
            baseTableName="amendment"
            referencedColumnNames="id"
            referencedTableName="responsible_party"
		/>
		<dropColumn columnName="person_id" tableName="amendment"/>
		<dropColumn columnName="organisation_name_id" tableName="amendment"/>

	</changeSet>





	<!-- association_type -->
	<changeSet author="julian" id="000009">
		<!-- name is primary key -->
		<renameColumn newColumnName="name" oldColumnName="association_type_name" tableName="association_type"/>
		<renameColumn newColumnName="description" oldColumnName="association_type_name_description" tableName="association_type"/>
	</changeSet>


	<!-- reference_source -->
	<changeSet author="julian" id="000010">
		<renameColumn newColumnName="id" oldColumnName="reference_id" tableName="reference_source"/>
		<sql>
			select exec('create sequence reference_source_id_seq start '||(select max(id) +1 from reference_source));
			alter table reference_source alter column id set default nextval('reference_source_id_seq')
		</sql>
		<renameColumn newColumnName="organisation_id" oldColumnName="organisation_name_id" tableName="reference_source"/>
	</changeSet>


	<!-- organisation synonym -->
	<changeSet author="julian" id="000011">
		<renameColumn newColumnName="id" oldColumnName="organisation_synonym_id" tableName="organisation_synonym"/>
		<sql>
			create sequence organisation_synonym_id_seq start 1;
			alter table organisation_synonym alter column id set default nextval('organisation_synonym_id_seq')
		</sql>
		<renameColumn newColumnName="name" oldColumnName="organisation_name" tableName="organisation_synonym"/>
		<renameColumn newColumnName="organisation_id" oldColumnName="organisation_name_id" tableName="organisation_synonym"/>
	</changeSet>


	<!-- affiliation_type -->
	<changeSet author="julian" id="000012">
		<!-- name is primary key -->
		<renameColumn newColumnName="name" oldColumnName="affiliation_type_name" tableName="affiliation_type"/>
		<renameColumn newColumnName="description" oldColumnName="affiliation_description" tableName="affiliation_type"/>
	</changeSet>



	<!-- person_organisational_affiliation  -->
	<!-- this is a composite primary key, should probably just be a unique constraint on the 3 terms
		or better - combine into the responsible_party concept
	-->
	<changeSet author="julian" id="000014">
		<renameColumn newColumnName="organisation_id" oldColumnName="organisation_name_id" tableName="person_organisational_affiliation"/>
	</changeSet>


	<!-- vocabulary_type -->
	<changeSet author="julian" id="000015">
		<!-- name is primary key -->
		<renameColumn newColumnName="name" oldColumnName="vocabulary_type_name" tableName="vocabulary_type"/>
		<renameColumn newColumnName="definition" oldColumnName="vocabulary_type_definition" tableName="vocabulary_type"/>
	</changeSet>


	<!-- internal_associated_terms  -->
	<changeSet author="julian" id="000017">
		<!-- nothing referencing, so doesn't need primary key -->

		<!-- avoid the indirection through the object_term and subject_term tables drop tables -->
		<addColumn tableName="internal_associated_terms">
			<column name="subject_vocabulary_term_id" type="integer"/>
		</addColumn>
		<addColumn tableName="internal_associated_terms">
			<column name="object_vocabulary_term_id" type="integer"/>
		</addColumn>
		<sql>
			-- note they exist as one-to-one mapping, but do it properly
			update internal_associated_terms ia
				set subject_vocabulary_term_id = vs.id,
				object_vocabulary_term_id = vo.id
				from subject_term s, object_term o, vocabulary_term vs, vocabulary_term vo
				where ia.subject_term_id = s.subject_term_id
				 and vs.name = s.vocabulary_term_name
				 and ia.object_term_id = o.object_term_id
				 and vo.name = o.vocabulary_term_name
		</sql>
	    <addForeignKeyConstraint
            constraintName="internal_associated_terms_subject_vocabulary_term_fkey"
			baseColumnNames="subject_vocabulary_term_id"
            baseTableName="internal_associated_terms"
            referencedColumnNames="id"
            referencedTableName="vocabulary_term"
		/>
	    <addForeignKeyConstraint
            constraintName="internal_associated_terms_object_vocabulary_term_fkey"
			baseColumnNames="object_vocabulary_term_id"
            baseTableName="internal_associated_terms"
            referencedColumnNames="id"
            referencedTableName="vocabulary_term"
		/>
		<dropColumn columnName="subject_term_id" tableName="internal_associated_terms"/>
		<dropColumn columnName="object_term_id" tableName="internal_associated_terms"/>
		<dropTable tableName="subject_term"/>
		<dropTable tableName="object_term"/>

		<!-- enforce tuple uniqueness - actually whole thing could be primary key -->
		<addUniqueConstraint columnNames="subject_vocabulary_term_id,object_vocabulary_term_id,association_type_name"
			tableName="internal_associated_terms" />

	</changeSet>



	<!-- term_category_classification -->
	<changeSet author="julian" id="000018">
		<!-- use vocabulary_term(id), and drop vocabulary_term_name -->
		<addColumn tableName="term_category_classification">
			<column name="vocabulary_term_id" type="integer"/>
		</addColumn>
		<sql>
			update term_category_classification tcc set vocabulary_term_id = vt.id
			from vocabulary_term vt
			where tcc.vocabulary_term_name = vt.name
		</sql>
	    <addForeignKeyConstraint
            constraintName="term_category_classification_vocabulary_term_fkey"
			baseColumnNames="vocabulary_term_id"
            baseTableName="term_category_classification"
            referencedColumnNames="id"
            referencedTableName="vocabulary_term"
		/>
		<dropColumn columnName="vocabulary_term_name" tableName="term_category_classification"/>
	</changeSet>


	<!-- classification_scheme to use responsible_party in place of person,organisation fields -->
	<changeSet author="julian" id="000016">
		<addColumn tableName="classification_scheme">
			<column name="responsible_party_id" type="integer"/>
		</addColumn>
		<sql>
			-- update classification_scheme set responsible_party_id = 2 -- Seb, Imos
			update classification_scheme cs set responsible_party_id = rp.id
			from responsible_party rp
			where cs.person_id = rp.person_id
			and cs.organisation_name_id = rp.organisation_id
		</sql>
	    <addForeignKeyConstraint
            constraintName="classification_scheme_responsible_party_fkey"
			baseColumnNames="responsible_party_id"
            baseTableName="classification_scheme"
            referencedColumnNames="id"
            referencedTableName="responsible_party"
		/>

		<dropColumn columnName="person_id" tableName="classification_scheme"/>
		<dropColumn columnName="organisation_name_id" tableName="classification_scheme"/>

		<renameColumn newColumnName="id" oldColumnName="classification_scheme_id" tableName="classification_scheme"/>
		<renameColumn newColumnName="name" oldColumnName="classification_scheme_name" tableName="classification_scheme"/>
		<renameColumn newColumnName="description" oldColumnName="classification_scheme_description" tableName="classification_scheme"/>
		<renameColumn newColumnName="title" oldColumnName="classification_scheme_title" tableName="classification_scheme"/>
		<!-- id is already primary but needs a sequence	-->
		<sql>
			select exec('create sequence classification_scheme_seq start '||(select max(id) +1 from classification_scheme));
			alter table classification_scheme alter column id set default nextval('classification_scheme_seq')
		</sql>
	</changeSet>


	<!-- classification_scheme_category -->
	<changeSet author="julian" id="000016-5">
		<!-- should name be called uri here 
			from rdf/skos pov yes, but maybe not from higher level pov
		--> 
		<renameColumn newColumnName="id" oldColumnName="classification_scheme_category_id" tableName="classification_scheme_category"/>
		<renameColumn newColumnName="name" oldColumnName="classification_scheme_category_name" tableName="classification_scheme_category"/>
		<renameColumn newColumnName="description" oldColumnName="classification_scheme_category_description" tableName="classification_scheme_category"/>
		<renameColumn newColumnName="label" oldColumnName="classification_scheme_category_label" tableName="classification_scheme_category"/>
		<!-- id is already primary but needs a sequence	-->
		<sql>
			select exec('create sequence classification_scheme_category_seq start '||(select max(id) +1 from classification_scheme_category));
			alter table classification_scheme_category alter column id set default nextval('classification_scheme_category_seq')
		</sql>
	</changeSet>


	<!-- classification_scheme_association -->
	<changeSet author="julian" id="000016-7">

		<!-- TODO make sure there's some good user views for this 
			especially to show the hierarchy_level. 
			- We could even annotate this within a custom namespace
			if we wanted
		-->

		<!-- normalize -->
		<dropColumn columnName="hierarchy_level" tableName="classification_scheme_association"/>
		<dropColumn columnName="parent_category_name" tableName="classification_scheme_association"/>
		<dropColumn columnName="parent_category_label" tableName="classification_scheme_association"/>
		<dropColumn columnName="classification_scheme_category_label" tableName="classification_scheme_association"/>

		<!-- classification_scheme_id is available via classification_scheme_id field of 
			of classification_scheme_category table which can be joined using classification_scheme_category_id 
			and appears to contain more complete data.
		--> 
		<dropColumn columnName="classification_scheme_id" tableName="classification_scheme_association"/>

		<!-- can be null, when it's root of the tree -->
		<renameColumn newColumnName="parent_classification_scheme_category_id" oldColumnName="parent_category_code" tableName="classification_scheme_association"/>
	    <addForeignKeyConstraint
            constraintName="classification_scheme_association_parent_classification_scheme_category_fkey"
			baseColumnNames="parent_classification_scheme_category_id"
            baseTableName="classification_scheme_association"
            referencedColumnNames="id"
            referencedTableName="classification_scheme_category"
		/>
	</changeSet>



	<!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->

	<!-- USER VIEWS
		join the tables up in some obvious ways, to aid understanding
	-->

	<!-- view of responsible party - should perhaps have association -->
	<changeSet author="julian" id="000019">
		<createView viewName="_responsible_party">
			select
				rp.id,
				p.name as person_name,
				o.acronym as organisation_acronym
			from responsible_party rp
			left join person p on p.id = rp.person_id
			left join organisation o on o.id = rp.organisation_id
		</createView>
	</changeSet>


	<!-- amendment -->
	<changeSet author="julian" id="000019-5">
		<createView viewName="_amendment">
			select
				trim(vt.uid) as uid,
				a.type,
				a.request_date,
				a.approval_date,
				vr.name as register_name,
				p.name as person_name,
				o.acronym as organisation_acronym
			from amendment a
			left join vocabulary_term vt on a.vocabulary_term_id = vt.id
			left join vocabulary_register vr on a.vocabulary_register_id = vr.id
			left join responsible_party rp on a.responsible_party_id = rp.id
			left join person p on p.id = rp.person_id
			left join organisation o on o.id = rp.organisation_id
		</createView>
	</changeSet>


	<!-- external associated terms -->
	<changeSet author="julian" id="000020">
		<createView viewName="_external_associated_terms">
			select
				trim(vt.uid) as uid,
				trim(vt.name) as name,
				trim(eat.uid) as external_uid,
				trim(association_type_name) as type
			from external_associated_terms eat
			left join vocabulary_term vt on eat.vocabulary_term_id = vt.id;
		</createView>
	</changeSet>



	<!-- internal associated terms -->
	<changeSet author="julian" id="000020-6">
		<createView viewName="_internal_associated_terms">
			select
				trim(association_type_name) as type,
				trim(svt.uid) as subject_uid,
				trim(svt.name) as subject_name,
				trim(ovt.uid) as object_uid,
				trim(ovt.name) as object_name
			from internal_associated_terms iat
			left join vocabulary_term svt on iat.subject_vocabulary_term_id = svt.id
			left join vocabulary_term ovt on iat.object_vocabulary_term_id = ovt.id
		</createView>
	</changeSet>

	<!-- we should put all these in a better order -->

	<changeSet author="julian" id="000020-7">
		<createView viewName="_reference_source">
			select
				trim( vt.uid) as uid,
				trim(vt.name) as name,
				rs.citation_string as citation_string,
				rs.online_reference_resource as online_reference_resource,
				o.acronym as organisation_acronym
			from vocabulary_term vt
			left join reference_source rs on vt.reference_source_id = rs.id
			left join organisation o on rs.organisation_id = o.id
		</createView>
	</changeSet>



	<!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->
	<!-- RDF views -->

	<!-- Concept Scheme -->

	<changeSet author="julian" id="000100-5">
		<createView viewName="_rdf_type_concept_scheme">    <!-- for classification scheme -->
			select
				s.name as subject,
				'rdf:type'::varchar as predicate,
				'skos:ConceptScheme'::varchar as object
			from classification_scheme s
		</createView>
	</changeSet>


	<!-- classification scheme -->

	<changeSet author="julian" id="000100-6">
		<createView viewName="_rdf_dcterms_issued">
			select
				s.name as subject,
				'dcterms:issued'::varchar as predicate,
				s.date_added::varchar as object
			from classification_scheme s
		</createView>
	</changeSet>


	<changeSet author="julian" id="000103">
		<createView viewName="_rdf_dc_title">
			select
				s.name as subject,
				'dc:title'::varchar as predicate,
				s.title as object
			from classification_scheme s
		</createView>
	</changeSet>

	<changeSet author="julian" id="000104">
		<createView viewName="_rdf_dc_description">
			select
				s.name as subject,
				'dc:description'::varchar as predicate,
				s.description as object
			from classification_scheme s
		</createView>
	</changeSet>


	<!-- we're dealing with persons not organisations here
		Mappings doc, suggests, should not include organisation here.
	-->

	<changeSet author="julian" id="000105">
		<createView viewName="_rdf_dc_creator">
			select
				s.name as subject,
				'dc:creator'::varchar as predicate,
				o.name as object
			from classification_scheme s
			join responsible_party rp on rp.id = s.responsible_party_id
			join organisation o on rp.organisation_id = o.id
		</createView>
	</changeSet>


	<changeSet author="julian" id="000106">
		<createView viewName="_rdf_dc_publisher">
			select
				s.name as subject,
				'dc:publisher'::varchar as predicate,
				p.name as object
			from classification_scheme s
			join responsible_party rp on rp.id = s.responsible_party_id
			join person p on rp.person_id = p.id
		</createView>
	</changeSet>



	<!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->
	<!-- TopConcept -->

	<changeSet author="julian" id="000106-1">
		<createView viewName="_rdf_type_top_concept">
			select
				c.name as subject,
				'rdf:type'::varchar as predicate,
				'skos:TopConcept'::varchar as object
			from classification_scheme_category c
			join classification_scheme_association a on c.id = a.classification_scheme_category_id
			where parent_classification_scheme_category_id is null
		</createView>
	</changeSet>


	<!-- concept -->

	<!-- should we capitalize the skos xml namespace ? -->

	<!-- this is for any category - not just top concept -->
	<changeSet author="julian" id="000107">
		<createView viewName="_rdf_skos_preflabel">
			select 
				c.name as subject,
				'skos:prefLabel'::varchar as predicate,
				c.label
			from classification_scheme_category c
		</createView>
	</changeSet>


	<!-- this is for any category - not just top concept -->
	<changeSet author="julian" id="000107-5">
		<createView viewName="_rdf_skos_definition">
			select 
				c.name as subject,
				'skos:definition'::varchar as predicate,
				c.description
			from classification_scheme_category c
		</createView>
	</changeSet>



	<!-- why not build aggregated views but group  somewhat -->

	<changeSet author="julian" id="000108">
		<createView viewName="_rdf_dcterms_issued_2">
			select
				c.name as subject,
				'dcterms:issued'::varchar as predicate,
				c.date_added::varchar as object
			from classification_scheme_category c
		</createView>
	</changeSet>


	<changeSet author="julian" id="000109">
		<createView viewName="_skos_inscheme">
			select 
				c.name as subject, 
				'skos:inScheme' as predicate, 
				s.name as object 
			from classification_scheme_category c 
			join classification_scheme s on c.classification_scheme_id = s.id;
		</createView>
	</changeSet>


	<changeSet author="julian" id="000110">
		<createView viewName="_skos_narrower">
			select 
				c2.name as subject, 
				'skos:narrower' as predicate, 
				c1.name as object
			from classification_scheme_association a 
			join classification_scheme_category c1 on a.classification_scheme_category_id = c1.id 
			join classification_scheme_category c2 on a.parent_classification_scheme_category_id = c2.id 
			-- order by c2.name, c1.name	
		</createView>
	</changeSet>


	<!-- TO DO irrespective of how we organize the union code, it doesn't make
		sense to have separate change sets for every view 

		we should be grouping  in the one changeset

		Also - Having an sql view of all the rdf is really useful,
			even if we didn't use it for template generation. 
	-->

	<!-- Concept -->

	<changeSet author="julian" id="000111">
		<createView viewName="_rdf_type_category">
			select
				c.name as subject,
				'rdf:type'::varchar as predicate,
				'skos:Concept'::varchar as object
			from classification_scheme_category c
		</createView>
	</changeSet>


	<changeSet author="julian" id="000112">
		<createView viewName="_skos_broader">
			select 
				c1.name as subject, 
				'skos:broader' as predicate, 
				c2.name as object
			from classification_scheme_association a 
			join classification_scheme_category c1 on a.classification_scheme_category_id = c1.id 
			join classification_scheme_category c2 on a.parent_classification_scheme_category_id = c2.id 
			-- order by c2.name, c1.name	
		</createView>
	</changeSet>



	<!-- ConceptScheme for parameter vocabulary --> 

	<changeSet author="julian" id="000113">
		<createView viewName="_rdf_type_concept_scheme_2"> <!-- for vocaublary register -->
			select
				r.uid as subject,
				'rdf:type'::varchar as predicate,
				'skos:ConceptScheme'::varchar as object
			from vocabulary_register r
		</createView>
	</changeSet>

	

	<!-- title is name --> 
	<changeSet author="julian" id="000114">
		<createView viewName="_rdf_dc_title_2">
			select 
				vr.uid as subject, 
				'dc:title'::varchar as predicate, 
				vr.name as object 
			from vocabulary_register vr
		</createView>
	</changeSet>
				
	<changeSet author="julian" id="000115">
		<createView viewName="_rdf_dc_description_2">
			select 
				vr.uid as subject, 
				'dc:description'::varchar as predicate, 
				vr.content_summary as object
			from vocabulary_register vr
		</createView>
	</changeSet>
	
	<changeSet author="julian" id="000116">
		<createView viewName="_rdf_dc_creator_2">
			select 
				vr.uid as subject, 
				'dc:creator'::varchar as predicate, 
				o.name
			from vocabulary_register vr
			join responsible_party rp on rp.id = vr. owner_responsible_party_id
			join organisation o on rp.organisation_id = o.id

		</createView>
	</changeSet>
	
		<!--	select vr.uid as subject, 'dc:creator'::varchar as predicate, o.name from vocabulary_register vr join responsible_party rp on rp.id = vr. owner_responsible_party_id join organisation o on rp.organisation_id = o.id

	-->

	<!--
		vocab=> select regexp_matches( 'http://vocab.aodn.org.au/def/ClassScheme/parameter1/Category/34', '.*/([0-9]*)$'  )    ;
			 regexp_matches 
			 {34}
			(1 row)
		vocab=> select  regexp_matches( 'http://vocab.aodn.org.au/def/ClassScheme/parameter1/Category/34', '(.*)/.*$'  )    ;
             regexp_matches
			 {http://vocab.aodn.org.au/def/ClassScheme/parameter1/Category}
			(1 row)
		But we can't manage to cast the result to an int ...
		select (regexp_matches( 'http://vocab.aodn.org.au/def/ClassScheme/parameter1/Category/34', '.*/([0-9]*)$'  ))[1]::int
		Adding this kind of order clause - prevents us from getting the values
		which is really odd.
		order by
        ((regexp_matches( _rdf.subject, $$.*/([0-9]*)$ $$  ))[1]::int)
	-->
	<!-- lets do all the views and then decide how we want to aggregate them organizing according to predicate.  -->
	<!-- aggregate -->

	<changeSet author="julian" id="000307">
		<createView viewName="_rdf">
			select * from _rdf_dcterms_issued

			union all select * from _rdf_type_concept_scheme

				-- rename to _rdf_concept_scheme_dc_publisher etc
			union all select * from _rdf_dc_publisher
			union all select * from _rdf_dc_title
			union all select * from _rdf_dc_description
			union all select * from _rdf_dc_creator
			union all select * from _rdf_dc_publisher

			union all select * from _rdf_type_top_concept

			union all select * from _rdf_skos_preflabel
			union all select * from _rdf_skos_definition

			union all select * from _rdf_dcterms_issued_2
			union all select * from _skos_inscheme
			union all select * from _skos_narrower
			union all select * from _skos_broader

			union all select * from _rdf_type_category

			union all select * from _rdf_type_concept_scheme_2
			union all select * from _rdf_dc_title_2
			union all select * from _rdf_dc_description_2
			union all select * from _rdf_dc_creator_2

			-- TODO get rid of this later for performance
			order by predicate, subject
		</createView>
	</changeSet>



	<!--changeSet author="julian" id="000308">
		<sql>
			CREATE FUNCTION rdf_object( predicate_ varchar, subject_ varchar  ) 
			RETURNS varchar AS $$
			DECLARE
			BEGIN
				select object from _rdf where predicate = $1 and subject = $2 ; 
			END;
			$$ LANGUAGE plpgsql;	
		</sql>
	</changeSet-->


</databaseChangeLog>




